<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>üìä Token Detail Report</title>
  <style>
    body { margin: 0; font-family: "Segoe UI", sans-serif; background: #0f0f23; color: #fff; }
    .nav { display: flex; justify-content: space-between; align-items: center; padding: 1rem 2rem; background: #1e1e38; }
    .nav a { color: #00d4ff; text-decoration: none; }
    .controls { display: flex; gap: 1rem; align-items: center; padding: 1rem 2rem; background: #16213e; flex-wrap: wrap; }
    
    /* Syst√®me d'onglets */
    .tabs-container { background: #16213e; border-bottom: 1px solid #2a2a4a; }
    .tabs { display: flex; padding: 0 2rem; gap: 0.5rem; }
    .tab { 
      padding: 1rem 1.5rem; 
      background: transparent; 
      border: none; 
      color: #888; 
      cursor: pointer; 
      border-bottom: 3px solid transparent;
      font-size: 0.9rem;
      font-weight: 500;
      transition: all 0.3s ease;
    }
    .tab:hover { color: #00d4ff; }
    .tab.active { 
      color: #00d4ff; 
      border-bottom-color: #00d4ff; 
      background: rgba(0, 212, 255, 0.1);
    }
    
    /* Contenu des onglets */
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    
    .filter-panel { padding: 1rem 2rem; background: #16213e; border-bottom: 1px solid #2a2a4a; }
    .filter-panel .filter-group { display: flex; gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem; }
    .filter-panel .filter-group label { margin-right: 0.5rem; color: #00d4ff; font-size: 0.9rem; }
    .filter-panel .filter-group input, .filter-panel .filter-group select { 
      padding: 0.4rem; border: none; border-radius: 4px; background: #2a2a4a; color: #fff; width: 100px; font-size: 0.9rem; 
    }
    .filter-panel .filter-group input:focus, .filter-panel .filter-group select:focus { 
      outline: none; border: 1px solid #00d4ff; 
    }
    .filter-panel .filter-group .time-filter { width: 120px; }
    .filter-panel .filter-group .time-unit { width: 80px; }
    .filter-panel .filter-group .bonding-filter { width: 120px; }
    
    table { width: 100%; border-collapse: collapse; margin-top: 1rem; font-size: 0.8rem; }
    th, td { padding: 0.4rem 0.3rem; border-bottom: 1px solid #2a2a4a; text-align: left; }
    th { background: #0f3460; position: sticky; top: 0; font-size: 0.75rem; }
    .price { color: #00ff88; font-weight: bold; }
    .score { color: #ffaa00; font-weight: bold; }
    .updated-recent { color: #00ff88; font-weight: bold; }
    .updated-old { color: #ff6b6b; }
    .updated-medium { color: #ffaa00; }
    .pagination { display: flex; gap: 0.5rem; padding: 1rem 2rem; justify-content: space-between; }
    .pagination button { padding: 0.4rem 0.8rem; border: none; border-radius: 4px; background: #00d4ff; color: #fff; cursor: pointer; }
    .pagination button:disabled { background: #444; cursor: not-allowed; }
    .fav { color: gold; cursor: pointer; }
    .no-data { text-align: center; padding: 1rem; color: #888; }
    .preset-buttons { display: flex; gap: 0.5rem; margin-bottom: 0.5rem; }
    .preset-btn { 
      padding: 0.3rem 0.6rem; border: none; border-radius: 3px; background: #2a2a4a; 
      color: #00d4ff; cursor: pointer; font-size: 0.8rem; 
    }
    .preset-btn:hover { background: #00d4ff; color: #fff; }
    .preset-btn.active { background: #00d4ff; color: #fff; }

    /* Contr√¥les auto-refresh */
    .auto-refresh-section {
        display: flex;
        align-items: center;
        gap: 1rem;
        padding: 0.5rem 1rem;
        background: #2a2a4a;
        border: 1px solid #444;
        border-radius: 6px;
        font-size: 0.9rem;
        margin-left: auto;
    }

    .toggle-switch {
        position: relative;
        width: 40px;
        height: 20px;
        background: #444;
        border-radius: 10px;
        cursor: pointer;
        transition: background 0.3s;
    }

    .toggle-switch.active { background: #00d4ff; }

    .toggle-switch::after {
        content: '';
        position: absolute;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: white;
        top: 2px;
        left: 2px;
        transition: transform 0.3s;
    }

    .toggle-switch.active::after { transform: translateX(20px); }

    /* Statuts bonding curve */
    .bonding-status {
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 0.7rem;
        font-weight: bold;
        text-transform: uppercase;
        display: inline-block;
        min-width: 60px;
        text-align: center;
    }

    .bonding-created { background: linear-gradient(45deg, #4CAF50, #8BC34A); color: #fff; }
    .bonding-active { background: linear-gradient(45deg, #FF9800, #FFC107); color: #000; }
    .bonding-completed { background: linear-gradient(45deg, #2196F3, #03A9F4); color: #fff; }
    .bonding-migrated { background: linear-gradient(45deg, #9C27B0, #E91E63); color: #fff; }
    .bonding-terminated { background: linear-gradient(45deg, #F44336, #FF5722); color: #fff; }

    /* Progress bar */
    .progress-container {
        width: 80px;
        height: 16px;
        background: #2a2a4a;
        border-radius: 8px;
        overflow: hidden;
        position: relative;
        border: 1px solid #444;
    }

    .progress-bar {
        height: 100%;
        border-radius: 8px;
        background: linear-gradient(90deg, #ff6b35, #00ff9d);
        transition: width 0.3s ease;
    }

    .progress-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.65rem;
        font-weight: bold;
        color: #fff;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        z-index: 2;
    }

    .no-progress { color: #666; font-size: 0.7rem; text-align: center; }

    /* Styles pour les changements de prix */
    .price-positive { color: #00ff88; }
    .price-negative { color: #ff6b6b; }
    .price-neutral { color: #888; }

    /* L√©gende des statuts */
    .status-legend {
        display: flex;
        gap: 1rem;
        padding: 0.5rem 1rem;
        background: rgba(42, 42, 74, 0.5);
        border-radius: 6px;
        margin-bottom: 1rem;
        flex-wrap: wrap;
        font-size: 0.8rem;
    }

    .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid #444;
        border-top: 2px solid #00ff88;
        border-radius: 50%;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Styles pour l'onglet analyse */
    .analysis-container { padding: 2rem; }
    .metrics-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1.5rem;
        margin-bottom: 2rem;
    }
    .metric-card {
        background: #1e1e38;
        padding: 1.5rem;
        border-radius: 8px;
        border: 1px solid #2a2a4a;
    }
    .metric-title {
        color: #00d4ff;
        font-size: 1.1rem;
        font-weight: bold;
        margin-bottom: 1rem;
    }
    .metric-value {
        font-size: 2rem;
        font-weight: bold;
        color: #fff;
        margin-bottom: 0.5rem;
    }
    .metric-subtitle {
        color: #888;
        font-size: 0.9rem;
    }

    /* Responsive */
    @media (max-width: 768px) {
        .tabs { padding: 0 1rem; }
        .filter-panel { padding: 1rem; }
        .controls { padding: 1rem; }
        th, td { padding: 0.3rem 0.2rem; font-size: 0.75rem; }
        .metrics-grid { grid-template-columns: 1fr; }
        table { font-size: 0.7rem; }
    }

    .token-status { padding: 3px 8px; border-radius: 12px; font-size: 0.7rem; font-weight: bold; text-transform: uppercase; display: inline-block; min-width: 60px; text-align: center; } 
    .status-active { background: linear-gradient(45deg, #4CAF50, #8BC34A); color: #fff; } 
    .status-inactive { background: linear-gradient(45deg, #FF9800, #FFC107); color: #000; } 
    .status-no_dex_data { background: linear-gradient(45deg, #607D8B, #90A4AE); color: #fff; } 
    .status-archived { background: linear-gradient(45deg, #9E9E9E, #BDBDBD); color: #000; } 
    .status-blacklisted { background: linear-gradient(45deg, #F44336, #FF5722); color: #fff; } 
    .status-unknown { background: linear-gradient(45deg, #424242, #616161); color: #fff; } 
    .status-filter { width: 140px; }

    .filter-active {
  background: #00d4ff !important;
  color: #fff !important;
  border: 1px solid #00d4ff;
  box-shadow: 0 0 8px #00d4ff;
}

.preset-btn.active {
  background: #00d4ff;
  color: #fff;
  border: 1px solid #00aaff;
  box-shadow: 0 0 8px rgba(0, 212, 255, 0.5);
  transform: scale(1.05);
  transition: all 0.2s ease;
}
.history-link {
  font-size: 0.7rem;
  color: #00d4ff;
  text-decoration: none;
  display: inline-block;
  margin-top: 2px;
}

.history-link:hover {
  color: #00aaff;
  text-decoration: underline;
}

.no-history {
  font-size: 0.7rem;
  color: #666;
}

  </style>
</head>
<body>
  <!-- Navigation -->
  <div class="nav">
    <h1>üìä Token Detail Report</h1>
    <a href="/dashboard">‚Üê Retour au Dashboard</a>
  </div>

  <!-- Contr√¥les -->
  <div class="controls">
    <button onclick="reloadData()">üîÑ Actualiser</button>
    <button onclick="resetFilters()">üßπ R√©initialiser Filtres</button>
    <label>Afficher
        <select id="perPage" onchange="changePerPage()">
            <option value="10">10</option>
            <option value="20">20</option>
            <option value="50">50</option>
            <option value="100">100</option>
        </select> tokens
    </label>
    
    <!-- Contr√¥le auto-refresh -->
            <div class="auto-refresh-section">
        <div class="auto-refresh-toggle">
            <label for="autoRefreshEnabled">Auto-refresh:</label>
            <div class="toggle-switch active" id="autoRefreshToggle" onclick="toggleAutoRefresh()"></div>
        </div>
        
        <select id="refreshInterval" onchange="updateRefreshInterval()">
            <option value="5000">5s</option>
            <option value="10000">10s</option>
            <option value="30000" selected>30s</option>
            <option value="60000">1min</option>
            <option value="300000">5min</option>
        </select>
        
        <div class="refresh-indicator active" id="refreshIndicator">
            <span>üîÑ</span>
            <span id="refreshStatus">Auto-refresh: 30s</span>
        </div>
    </div>
  </div>

  <!-- Onglets -->
  <div class="tabs-container">
    <div class="tabs">
      <button class="tab active" onclick="switchTab('base', this)">üìä Donn√©es de Base</button>
      <button class="tab" onclick="switchTab('dexscreener', this)">üìà DexScreener</button>
      <button class="tab" onclick="switchTab('analysis', this)">üî¨ Analyse</button>
    </div>
  </div>

  <!-- Contenu Onglet Donn√©es de Base -->
  <div id="base-content" class="tab-content active">
    <!-- L√©gende des statuts -->
    <div class="status-legend">
      <div class="legend-item">
          <span class="bonding-status bonding-created">Created</span>
          <span>Nouveau token d√©tect√©</span>
      </div>
      <div class="legend-item">
          <span class="bonding-status bonding-active">Active</span>
          <span>Bonding curve en cours</span>
      </div>
      <div class="legend-item">
          <span class="bonding-status bonding-completed">Completed</span>
          <span>Bonding curve termin√©e</span>
      </div>
      <div class="legend-item">
          <span class="bonding-status bonding-migrated">Migrated</span>
          <span>Migr√© vers Raydium</span>
      </div>
      <div class="legend-item">
          <span class="bonding-status bonding-terminated">Terminated</span>
          <span>Bonding curve arr√™t√©e</span>
      </div>
    </div>

    <!-- Panneau des filtres -->
    <div class="filter-panel">
      <!-- Filtres temporels avec boutons pr√©sets -->
      <div class="filter-group">
        <label>üïí Mis √† jour depuis:</label>
        <div class="preset-buttons">
          <button class="preset-btn" onclick="setTimeFilter(15, 'minutes',this)">15min</button>
          <button class="preset-btn" onclick="setTimeFilter(30, 'minutes',this)">30min</button>
          <button class="preset-btn" onclick="setTimeFilter(1, 'hours',this)">1h</button>
          <button class="preset-btn" onclick="setTimeFilter(6, 'hours',this)">6h</button>
          <button class="preset-btn" onclick="setTimeFilter(24, 'hours',this)">24h</button>
          <button class="preset-btn" onclick="clearTimeFilter(this)">Tout</button>
        </div>
        <input type="number" id="filterTimeValue" class="time-filter" placeholder="Valeur" min="1">
        <select id="filterTimeUnit" class="time-unit">
          <option value="">-</option>
          <option value="minutes">Minutes</option>
          <option value="hours">Heures</option>
          <option value="days">Jours</option>
        </select>
      </div>
      
      <div class="filter-group">
        <label>Symbol:</label><input type="text" id="filterSymbol" placeholder="Symbol (e.g., DNT)">
        
        <!-- Nouveau filtre Bonding Curve -->
        <label>üîó Bonding Curve:</label>
        <select id="filterBondingStatus" class="bonding-filter">
          <option value="">Tous les statuts</option>
          <option value="created">Created (Nouveau)</option>
          <option value="active">Active (En cours)</option>
          <option value="completed">Completed (Termin√©e)</option>
          <option value="migrated">Migrated (Migr√©e)</option>
          <option value="terminated">Terminated (Arr√™t√©e)</option>
          <option value="unknown">Unknown (Inconnu)</option>
        </select>
        
        <label>üìä Progress Min (%):</label><input type="number" id="filterProgressMin" placeholder="Min %" min="0" max="100" step="1" style="width: 80px;">
        <label>Progress Max (%):</label><input type="number" id="filterProgressMax" placeholder="Max %" min="0" max="100" step="1" style="width: 80px;">
        
        <label>Price Min ($):</label><input type="number" id="filterPriceMin" placeholder="Min" step="0.000001">
        <label>Price Max ($):</label><input type="number" id="filterPriceMax" placeholder="Max" step="0.000001">
      </div>
      
      <div class="filter-group">
        <label>Score Min:</label><input type="number" id="filterScoreMin" placeholder="Min" step="0.1">
        <label>Score Max:</label><input type="number" id="filterScoreMax" placeholder="Max" step="0.1">
        <label>Liquidity Min ($):</label><input type="number" id="filterLiquidityMin" placeholder="Min 5000" title="Recommand√©: ‚â• 5,000 $">
        <label>Liquidity Max ($):</label><input type="number" id="filterLiquidityMax" placeholder="Max">
        <label>Volume Min ($):</label><input type="number" id="filterVolumeMin" placeholder="Min 100000" title="Recommand√©: ‚â• 100,000 $">
        <label>Volume Max ($):</label><input type="number" id="filterVolumeMax" placeholder="Max">
      </div>
      
      <div class="filter-group">
        <label>Holders Min:</label><input type="number" id="filterHoldersMin" placeholder="Min 500" title="Recommand√©: ‚â• 500">
        <label>Holders Max:</label><input type="number" id="filterHoldersMax" placeholder="Max">
        <label>Age Min (h):</label><input type="number" id="filterAgeMin" placeholder="Min 6" step="0.1" title="Recommand√©: ‚â• 6 heures">
        <label>Age Max (h):</label><input type="number" id="filterAgeMax" placeholder="Max" step="0.1">
        <label>Risk Min:</label><input type="number" id="filterRiskMin" placeholder="Min">
        <label>Risk Max:</label><input type="number" id="filterRiskMax" placeholder="Max 50" title="Recommand√©: ‚â§ 50">
        <label>Date D√©couverte:</label><input type="date" id="filterDiscoveredAt" placeholder="Discovered At">
      </div>
    </div>

    <!-- Tableau donn√©es de base -->
    <table id="baseTable">
      <thead>
        <tr>
          <th>‚≠ê</th>
          <th>Symbol</th>
          <th>Price ($)</th>
          <th>Score</th>
          <th>Liquidity ($)</th>
          <th>Volume 24h ($)</th>
          <th>Holders</th>
          <th>Age (h)</th>
          <th>Risk</th>
          <th>Bonding Curve</th>
          <th>Progress</th>
          <th>Derni√®re MAJ</th>
          <th>D√©couvert</th>
        </tr>
      </thead>
      <tbody id="baseTbody"></tbody>
    </table>
  </div>

  <!-- Contenu Onglet DexScreener -->
  <div id="dexscreener-content" class="tab-content">
    <div class="filter-panel">
      <div class="filter-group">
        <label>Symbol:</label><input type="text" id="dexFilterSymbol" placeholder="Symbol">
        <label>üìä Status:</label> <select id="dexFilterStatus" class="status-filter"> <option value="">Tous les status</option> <option value="active">Active</option> <option value="inactive">Inactive</option> <option value="no_dex_data">No Dex Data</option> <option value="archived">Archived</option> <option value="blacklisted">Blacklisted</option> </select>
        <label>Prix DexScreener Min ($):</label><input type="number" id="dexFilterPriceMin" placeholder="Min" step="0.000001">
        <label>Prix DexScreener Max ($):</label><input type="number" id="dexFilterPriceMax" placeholder="Max" step="0.000001">
        <label>Market Cap Min ($):</label><input type="number" id="dexFilterMarketCapMin" placeholder="Min">
        <label>Market Cap Max ($):</label><input type="number" id="dexFilterMarketCapMax" placeholder="Max">
      </div>
      <div class="filter-group">
        <label>Volume 1h Min:</label><input type="number" id="dexFilterVolume1hMin" placeholder="Min">
        <label>Volume 6h Min:</label><input type="number" id="dexFilterVolume6hMin" placeholder="Min">
        <label>Volume 24h Min:</label><input type="number" id="dexFilterVolume24hMin" placeholder="Min">
        <label>Transactions 24h Min:</label><input type="number" id="dexFilterTxns24hMin" placeholder="Min">
      </div>
      <div class="filter-group">
        <label>Buys 24h Min:</label><input type="number" id="dexFilterBuys24hMin" placeholder="Min">
        <label>Sells 24h Max:</label><input type="number" id="dexFilterSells24hMax" placeholder="Max">
        <label>Liquidity Quote Min:</label><input type="number" id="dexFilterLiquidityQuoteMin" placeholder="Min">
        <label>Avec donn√©es DexScreener:</label>
        <select id="dexFilterHasData">
          <option value="">Tous</option>
          <option value="true">Oui</option>
          <option value="false">Non</option>
        </select>
      </div>
      <div class="filter-group">
        <label>Derni√®re MAJ DexScreener:</label>
        <div class="preset-buttons">
          <button class="preset-btn" onclick="setDexTimeFilter(1, 'hours', this)">1h</button>
          <button class="preset-btn" onclick="setDexTimeFilter(6, 'hours', this)">6h</button>
          <button class="preset-btn" onclick="setDexTimeFilter(24, 'hours', this)">24h</button>
          <button class="preset-btn" onclick="clearDexTimeFilter(this)">Tout</button>
        </div>
      </div>
    </div>

    <!-- Tableau DexScreener -->
    <table id="dexscreenerTable">
      <thead>
        <tr>
          <th>‚≠ê</th>
          <th>Symbol / Actions</th>
          <th>Status</th>
          <th>Prix DS ($)</th>
          <th>Market Cap ($)</th>
          <th>Liq. Base</th>
          <th>Liq. Quote ($)</th>
          <th>Vol 1h ($)</th>
          <th>Vol 6h ($)</th>
          <th>Vol 24h ($)</th>
          <th>Œî Prix 1h (%)</th>
          <th>Œî Prix 6h (%)</th>
          <th>Œî Prix 24h (%)</th>
          <th>Txns 1h</th>
          <th>Txns 6h</th>
          <th>Txns 24h</th>
          <th>Buys 1h</th>
          <th>Sells 1h</th>
          <th>Buys 24h</th>
          <th>Sells 24h</th>
          <th>URL DexScreener</th>
          <th>Cr√©√© le</th>
          <th>MAJ DS</th>
        </tr>
      </thead>
      <tbody id="dexscreenerTbody"></tbody>
    </table>
  </div>

  <!-- Contenu Onglet Analyse -->
  <div id="analysis-content" class="tab-content">
    <div class="analysis-container">
      <h2>üìä Analyse des Donn√©es</h2>
      
      <div class="metrics-grid" id="analysisMetrics">
        <!-- Les m√©triques seront g√©n√©r√©es dynamiquement -->
      </div>
      
      <div class="chart-placeholder">
        üìà Graphiques d'analyse en temps r√©el
        <br><br>
        ‚Ä¢ Distribution des scores d'investissement<br>
        ‚Ä¢ √âvolution des volumes 24h<br>
        ‚Ä¢ R√©partition par statut bonding curve<br>
        ‚Ä¢ Corr√©lation price vs liquidity<br>
        ‚Ä¢ Analyse DexScreener vs donn√©es internes
      </div>
    </div>
  </div>

  <!-- Pagination -->
  <div class="pagination">
    <button id="prevBtn" onclick="prevPage()">Pr√©c√©dent</button>
    <span id="pageInfo"></span>
    <button id="nextBtn" onclick="nextPage()">Suivant</button>
  </div>

  <script>
    let data = [], filteredData = [], currentPage = 1, perPage = 10;
    let refreshInterval = 30000;
    let refreshTimer = null;
    let isAutoRefreshEnabled = true;
    let currentTab = 'base';

    // === GESTION DES ONGLETS ===
    function switchTab(tabName, button) {
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      document.getElementById(tabName + '-content').classList.add('active');
      button.classList.add('active');
      
      currentTab = tabName;
      renderPage();
    }

    
    // === FONCTIONS UTILITAIRES ===
    function parseDateTime(dateString) {
      if (!dateString) return null;
      
      if (dateString.includes('T') || dateString.includes('Z')) {
        return new Date(dateString);
      } else {
        return new Date(dateString.replace(' ', 'T'));
      }
    }

    function formatLocalDateTime(dateString) {
      if (!dateString) return 'Inconnue';
      
      const date = parseDateTime(dateString);
      if (!date || isNaN(date.getTime())) return 'Invalide';
      
      return date.toLocaleString('fr-FR', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      });
    }

    function getTimeAgo(dateString) {
      if (!dateString) return { text: 'Inconnue', className: 'updated-old' };
      
      const now = new Date();
      const updateTime = parseDateTime(dateString);
      
      if (!updateTime || isNaN(updateTime.getTime())) {
        return { text: 'Invalide', className: 'updated-old' };
      }
      
      const diffMs = now - updateTime;
      const diffMinutes = Math.floor(diffMs / (1000 * 60));
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
      
      let text, className;
      
      if (diffMinutes < 1) {
        text = '√Ä l\'instant';
        className = 'updated-recent';
      } else if (diffMinutes < 60) {
        text = `${diffMinutes}min`;
        className = diffMinutes < 30 ? 'updated-recent' : 'updated-medium';
      } else if (diffHours < 24) {
        text = `${diffHours}h`;
        className = diffHours < 6 ? 'updated-medium' : 'updated-old';
      } else {
        text = `${diffDays}j`;
        className = 'updated-old';
      }
      
      return { text, className };
    }

    function formatPriceChange(value) {
      if (!value || value === 0) return { text: '0.00%', className: 'price-neutral' };
      
      const percentage = parseFloat(value).toFixed(2);
      const className = value > 0 ? 'price-positive' : 'price-negative';
      const prefix = value > 0 ? '+' : '';
      
      return { text: `${prefix}${percentage}%`, className };
    }

    // === FONCTIONS AUTO-REFRESH ===
    function toggleAutoRefresh() {
        isAutoRefreshEnabled = !isAutoRefreshEnabled;
        const toggle = document.getElementById('autoRefreshToggle');
        const indicator = document.getElementById('refreshIndicator');
        
        if (isAutoRefreshEnabled) {
            toggle.classList.add('active');
            indicator.classList.remove('paused');
            indicator.classList.add('active');
            startAutoRefresh();
        } else {
            toggle.classList.remove('active');
            indicator.classList.remove('active');
            indicator.classList.add('paused');
            stopAutoRefresh();
        }
        
        updateRefreshStatus();
    }

    function updateRefreshInterval() {
        const select = document.getElementById('refreshInterval');
        refreshInterval = parseInt(select.value);
        
        if (isAutoRefreshEnabled) {
            stopAutoRefresh();
            startAutoRefresh();
        }
        
        updateRefreshStatus();
    }

    function startAutoRefresh() {
        if (refreshTimer) clearInterval(refreshTimer);
        
        if (isAutoRefreshEnabled) {
            refreshTimer = setInterval(() => {
                fetchData();
            }, refreshInterval);
        }
    }

    function stopAutoRefresh() {
        if (refreshTimer) {
            clearInterval(refreshTimer);
            refreshTimer = null;
        }
    }

    function updateRefreshStatus() {
        const statusElement = document.getElementById('refreshStatus');
        const intervalText = refreshInterval >= 60000 ? 
            `${refreshInterval/60000}min` : 
            `${refreshInterval/1000}s`;
        
        if (isAutoRefreshEnabled) {
            statusElement.textContent = `Auto-refresh: ${intervalText}`;
        } else {
            statusElement.textContent = `Paused (${intervalText})`;
        }
    }

    function showRefreshIndicator(active) {
        const indicator = document.getElementById('refreshIndicator');
        if (!indicator) return;
        
        if (active && isAutoRefreshEnabled) {
            indicator.innerHTML = `
                <div class="spinner"></div>
                <span>Actualisation...</span>
            `;
        } else {
            const intervalText = refreshInterval >= 60000 ? 
                `${refreshInterval/60000}min` : 
                `${refreshInterval/1000}s`;
            
            const statusText = isAutoRefreshEnabled ? 
                `Auto-refresh: ${intervalText}` : 
                `Paused (${intervalText})`;
                
            indicator.innerHTML = `
                <span>${isAutoRefreshEnabled ? 'üîÑ' : '‚è∏Ô∏è'}</span>
                <span>${statusText}</span>
            `;
        }
    }

    // === FONCTIONS PROGRESSION BONDING CURVE ===
    function getBondingProgressDisplay(status, progress) {
        if (!status || !['active', 'created'].includes(status.toLowerCase())) {
            return '<div class="no-progress">N/A</div>';
        }
        
        const progressValue = parseFloat(progress) || 0;
        
        if (progressValue <= 0) {
            return '<div class="no-progress">0%</div>';
        }
        
        let progressClass = '';
        if (progressValue >= 90) {
            progressClass = 'completed';
        } else if (progressValue < 30) {
            progressClass = 'low';
        }
        
        return `
            <div class="progress-container ${progressClass}" title="Progression: ${progressValue}%">
                <div class="progress-bar" style="width: ${Math.min(progressValue, 100)}%"></div>
                <div class="progress-text">${progressValue}%</div>
            </div>
        `;
    }

    function getBondingCurveDisplay(status) {
        if (!status) return '<span class="bonding-status bonding-unknown">Unknown</span>';
        
        const statusLower = String(status).toLowerCase().trim();
        const statusMap = {
            'created': '<span class="bonding-status bonding-created">Created</span>',
            'active': '<span class="bonding-status bonding-active">Active</span>',
            'completed': '<span class="bonding-status bonding-completed">Completed</span>',
            'migrated': '<span class="bonding-status bonding-migrated">Migrated</span>',
            'terminated': '<span class="bonding-status bonding-terminated">Terminated</span>'
        };
        
        return statusMap[statusLower] || 
               `<span class="bonding-status bonding-unknown">${status}</span>`;
    }

    // === FONCTIONS DE DONN√âES ===
    async function fetchData() {
      if (!isAutoRefreshEnabled) {
        return;
      }
      
      showRefreshIndicator(true);
      try {
        const response = await fetch('/api/tokens-detail');
        if (!response.ok) throw new Error('R√©ponse API invalide');
        data = await response.json();
        filteredData = [...data];
        currentPage = 1;
        renderPage();
        
        if (currentTab === 'analysis') {
          updateAnalysis();
        }
      } catch (error) {
        console.error('Erreur lors du chargement des donn√©es:', error);
        const tbody = document.getElementById('baseTbody');
        if (tbody) {
          tbody.innerHTML = '<tr><td colspan="13">Erreur lors du chargement des donn√©es</td></tr>';
        }
      } finally {
        showRefreshIndicator(false);
      }
    }

    function isWithinTimeFilter(dateString, filterValue, filterUnit) {
      if (!dateString || !filterValue || !filterUnit) return true;
      
      const now = new Date();
      const updateTime = parseDateTime(dateString);
      
      if (!updateTime || isNaN(updateTime.getTime())) return false;
      
      const diffMs = now - updateTime;
      
      let thresholdMs;
      switch (filterUnit) {
        case 'minutes':
          thresholdMs = filterValue * 60 * 1000;
          break;
        case 'hours':
          thresholdMs = filterValue * 60 * 60 * 1000;
          break;
        case 'days':
          thresholdMs = filterValue * 24 * 60 * 60 * 1000;
          break;
        default:
          return true;
      }
      
      return diffMs <= thresholdMs;
    }

    // === FONCTIONS DE FILTRAGE ===
    function setTimeFilter(value, unit) {
      document.getElementById('filterTimeValue').value = value;
      document.getElementById('filterTimeUnit').value = unit;
      
      document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      applyFilters();
      //event.target.classList.add('active');
    }

    function clearTimeFilter() {
      document.getElementById('filterTimeValue').value = '';
      document.getElementById('filterTimeUnit').value = '';
      
      document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      applyFilters();
      //event.target.classList.add('active');
      
      applyFilters();
    }

    function setDexTimeFilter(value, unit, btn) {
  window.dexTimeValue = value;
  window.dexTimeUnit = unit;
  document.querySelectorAll('#dexscreener-content .preset-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  applyDexFilters();
}

function clearDexTimeFilter(btn) {
  window.dexTimeValue = null;
  window.dexTimeUnit = null;
  document.querySelectorAll('#dexscreener-content .preset-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');
  applyDexFilters();
}

    function applyFilters() {
      const filters = {
        symbol: document.getElementById('filterSymbol').value.toLowerCase().trim(),
        bondingStatus: document.getElementById('filterBondingStatus').value.toLowerCase().trim(),
        progressMin: document.getElementById('filterProgressMin').value ? parseFloat(document.getElementById('filterProgressMin').value) : null,
        progressMax: document.getElementById('filterProgressMax').value ? parseFloat(document.getElementById('filterProgressMax').value) : null,
        priceMin: document.getElementById('filterPriceMin').value ? parseFloat(document.getElementById('filterPriceMin').value) : null,
        priceMax: document.getElementById('filterPriceMax').value ? parseFloat(document.getElementById('filterPriceMax').value) : null,
        scoreMin: document.getElementById('filterScoreMin').value ? parseFloat(document.getElementById('filterScoreMin').value) : null,
        scoreMax: document.getElementById('filterScoreMax').value ? parseFloat(document.getElementById('filterScoreMax').value) : null,
        liquidityMin: document.getElementById('filterLiquidityMin').value ? parseFloat(document.getElementById('filterLiquidityMin').value) : null,
        liquidityMax: document.getElementById('filterLiquidityMax').value ? parseFloat(document.getElementById('filterLiquidityMax').value) : null,
        volumeMin: document.getElementById('filterVolumeMin').value ? parseFloat(document.getElementById('filterVolumeMin').value) : null,
        volumeMax: document.getElementById('filterVolumeMax').value ? parseFloat(document.getElementById('filterVolumeMax').value) : null,
        holdersMin: document.getElementById('filterHoldersMin').value ? parseInt(document.getElementById('filterHoldersMin').value) : null,
        holdersMax: document.getElementById('filterHoldersMax').value ? parseInt(document.getElementById('filterHoldersMax').value) : null,
        ageMin: document.getElementById('filterAgeMin').value ? parseFloat(document.getElementById('filterAgeMin').value) : null,
        ageMax: document.getElementById('filterAgeMax').value ? parseFloat(document.getElementById('filterAgeMax').value) : null,
        riskMin: document.getElementById('filterRiskMin').value ? parseInt(document.getElementById('filterRiskMin').value) : null,
        riskMax: document.getElementById('filterRiskMax').value ? parseInt(document.getElementById('filterRiskMax').value) : null,
        discoveredAt: document.getElementById('filterDiscoveredAt').value,
        timeValue: document.getElementById('filterTimeValue').value ? parseInt(document.getElementById('filterTimeValue').value) : null,
        timeUnit: document.getElementById('filterTimeUnit').value
      };

      filteredData = data.filter(row => {
        const riskValue = 100 - (row.rug_score || 50);
        const updatedAt = row.updated_at || row.first_discovered_at;
        const rowBondingStatus = (row.bonding_curve_status || '').toLowerCase();
        const progressValue = parseFloat(row.bonding_curve_progress) || 0;
        highlightActiveFilters();
        return (
          (!filters.symbol || row.symbol.toLowerCase().includes(filters.symbol)) &&
          (!filters.bondingStatus || rowBondingStatus === filters.bondingStatus) &&
          (filters.progressMin === null || progressValue >= filters.progressMin) &&
          (filters.progressMax === null || progressValue <= filters.progressMax) &&
          (filters.priceMin === null || row.price_usdc >= filters.priceMin) &&
          (filters.priceMax === null || row.price_usdc <= filters.priceMax) &&
          (filters.scoreMin === null || row.invest_score >= filters.scoreMin) &&
          (filters.scoreMax === null || row.invest_score <= filters.scoreMax) &&
          (filters.liquidityMin === null || row.liquidity_usd >= filters.liquidityMin) &&
          (filters.liquidityMax === null || row.liquidity_usd <= filters.liquidityMax) &&
          (filters.volumeMin === null || row.volume_24h >= filters.volumeMin) &&
          (filters.volumeMax === null || row.volume_24h <= filters.volumeMax) &&
          (filters.holdersMin === null || row.holders >= filters.holdersMin) &&
          (filters.holdersMax === null || row.holders <= filters.holdersMax) &&
          (filters.ageMin === null || row.age_hours >= filters.ageMin) &&
          (filters.ageMax === null || row.age_hours <= filters.ageMax) &&
          (filters.riskMin === null || riskValue >= filters.riskMin) &&
          (filters.riskMax === null || riskValue <= filters.riskMax) &&
          (!filters.discoveredAt || new Date(row.first_discovered_at).toISOString().startsWith(filters.discoveredAt)) &&
          isWithinTimeFilter(updatedAt, filters.timeValue, filters.timeUnit) &&
          (!window.dexTimeValue || !window.dexTimeUnit || isWithinTimeFilter(lastDexUpdate, window.dexTimeValue, window.dexTimeUnit))
        );
      });

      currentPage = 1;
      renderPage();
    }

    function applyDexFilters() {
      
      const dexFilters = {
        symbol: document.getElementById('dexFilterSymbol').value.toLowerCase().trim(),
        status: document.getElementById('dexFilterStatus').value.toLowerCase().trim(),
        priceMin: document.getElementById('dexFilterPriceMin').value ? parseFloat(document.getElementById('dexFilterPriceMin').value) : null,
        priceMax: document.getElementById('dexFilterPriceMax').value ? parseFloat(document.getElementById('dexFilterPriceMax').value) : null,
        marketCapMin: document.getElementById('dexFilterMarketCapMin').value ? parseFloat(document.getElementById('dexFilterMarketCapMin').value) : null,
        marketCapMax: document.getElementById('dexFilterMarketCapMax').value ? parseFloat(document.getElementById('dexFilterMarketCapMax').value) : null,
        volume1hMin: document.getElementById('dexFilterVolume1hMin').value ? parseFloat(document.getElementById('dexFilterVolume1hMin').value) : null,
        volume6hMin: document.getElementById('dexFilterVolume6hMin').value ? parseFloat(document.getElementById('dexFilterVolume6hMin').value) : null,
        volume24hMin: document.getElementById('dexFilterVolume24hMin').value ? parseFloat(document.getElementById('dexFilterVolume24hMin').value) : null,
        txns24hMin: document.getElementById('dexFilterTxns24hMin').value ? parseFloat(document.getElementById('dexFilterTxns24hMin').value) : null,
        buys24hMin: document.getElementById('dexFilterBuys24hMin').value ? parseFloat(document.getElementById('dexFilterBuys24hMin').value) : null,
        sells24hMax: document.getElementById('dexFilterSells24hMax').value ? parseFloat(document.getElementById('dexFilterSells24hMax').value) : null,
        liquidityQuoteMin: document.getElementById('dexFilterLiquidityQuoteMin').value ? parseFloat(document.getElementById('dexFilterLiquidityQuoteMin').value) : null,
        hasData: document.getElementById('dexFilterHasData').value,
        dexTimeValue: null,
        dexTimeUnit: ''
      };

      filteredData = data.filter(row => {
        const hasDexData = (row.dexscreener_price_usd || 0) > 0;
        const lastDexUpdate = row.last_dexscreener_update || row.updated_at;
        highlightActiveFilters();
        return (
          (!dexFilters.symbol || row.symbol.toLowerCase().includes(dexFilters.symbol)) &&
          (!dexFilters.status || row.status.toLowerCase() === dexFilters.status) &&
          (dexFilters.priceMin === null || (row.dexscreener_price_usd || 0) >= dexFilters.priceMin) &&
          (dexFilters.priceMax === null || (row.dexscreener_price_usd || 0) <= dexFilters.priceMax) &&
          (dexFilters.marketCapMin === null || (row.dexscreener_market_cap || 0) >= dexFilters.marketCapMin) &&
          (dexFilters.marketCapMax === null || (row.dexscreener_market_cap || 0) <= dexFilters.marketCapMax) &&
          (dexFilters.volume1hMin === null || (row.dexscreener_volume_1h || 0) >= dexFilters.volume1hMin) &&
          (dexFilters.volume6hMin === null || (row.dexscreener_volume_6h || 0) >= dexFilters.volume6hMin) &&
          (dexFilters.volume24hMin === null || (row.dexscreener_volume_24h || 0) >= dexFilters.volume24hMin) &&
          (dexFilters.txns24hMin === null || (row.dexscreener_txns_24h || 0) >= dexFilters.txns24hMin) &&
          (dexFilters.buys24hMin === null || (row.dexscreener_buys_24h || 0) >= dexFilters.buys24hMin) &&
          (dexFilters.sells24hMax === null || (row.dexscreener_sells_24h || 0) <= dexFilters.sells24hMax) &&
          (dexFilters.liquidityQuoteMin === null || (row.dexscreener_liquidity_quote || 0) >= dexFilters.liquidityQuoteMin) &&
          (!dexFilters.hasData || (dexFilters.hasData === 'true' ? hasDexData : !hasDexData)) &&
          (!window.dexTimeValue || !window.dexTimeUnit || isWithinTimeFilter(lastDexUpdate, window.dexTimeValue, window.dexTimeUnit))
        );
      });

      currentPage = 1;
      renderPage();
    }

    // === FONCTIONS D'AFFICHAGE ===
    function renderPage() {
      const start = (currentPage - 1) * perPage;
      const rows = filteredData.slice(start, start + perPage);
      
      if (currentTab === 'base') {
        renderBaseTable(rows);
      } else if (currentTab === 'dexscreener') {
        renderDexScreenerTable(rows);
      } else if (currentTab === 'analysis') {
        updateAnalysis();
      }
      
      updatePagination();
    }

    function renderBaseTable(rows) {
      const tbody = document.getElementById('baseTbody');
      
      if (rows.length === 0) {
        tbody.innerHTML = '<tr><td colspan="13" class="no-data">Aucune donn√©e ne correspond aux filtres</td></tr>';
      } else {
        tbody.innerHTML = rows.map(r => {
          const updatedAt = r.updated_at || r.first_discovered_at;
          const timeAgo = getTimeAgo(updatedAt);
          const discoveredAt = formatLocalDateTime(r.first_discovered_at);
          const fullUpdateTime = formatLocalDateTime(updatedAt);
          const bondingCurveDisplay = getBondingCurveDisplay(r.bonding_curve_status);
          const progressDisplay = getBondingProgressDisplay(r.bonding_curve_status, r.bonding_curve_progress);
          
          return `
            <tr>
              <td><span class="fav" onclick="toggleFav('${r.address}')">‚≠ê</span></td>
              <td><a href="https://dexscreener.com/solana/${r.address}" target="_blank">${r.symbol}</a></td>
              <td class="price">${(+r.price_usdc || 0).toFixed(8)}</td>
              <td class="score">${(+r.invest_score || 0).toFixed(1)}</td>
              <td>${Math.round(r.liquidity_usd || 0).toLocaleString()}</td>
              <td>${Math.round(r.volume_24h || 0).toLocaleString()}</td>
              <td>${r.holders || 0}</td>
              <td>${(+r.age_hours || 0).toFixed(1)}</td>
              <td>${Math.round(100 - (r.rug_score || 50))}</td>
              <td>${bondingCurveDisplay}</td>
              <td>${progressDisplay}</td>
              <td class="${timeAgo.className}" title="${fullUpdateTime}">${timeAgo.text}</td>
              <td title="${discoveredAt}">${discoveredAt}</td>
            </tr>
          `;
        }).join('');
      }
    }

    function renderDexScreenerTable(rows) {
      const tbody = document.getElementById('dexscreenerTbody');
      
      if (rows.length === 0) {
        tbody.innerHTML = '<tr><td colspan="22" class="no-data">Aucune donn√©e ne correspond aux filtres</td></tr>';
      } else {
        tbody.innerHTML = rows.map(r => {
          // ‚úÖ MISE √Ä JOUR: Utiliser l'URL g√©n√©r√©e par l'API ou construire l'URL
          const dexUrl = r.dexscreener_url || `https://dexscreener.com/solana/${r.address}`;
          const dexUrlDisplay = (r.dexscreener_price_usd || 0) > 0 ? 
            `<a href="${dexUrl}" target="_blank">üîó Voir</a>` : 
            'N/A';
          
          // ‚úÖ MISE √Ä JOUR: Utiliser les vraies colonnes de la base de donn√©es
          const pairCreatedAt = formatLocalDateTime(r.dexscreener_pair_created_at);
          const lastDexUpdate = formatLocalDateTime(r.last_dexscreener_update || r.updated_at);
          
          // ‚úÖ MISE √Ä JOUR: Formatage des changements de prix avec couleurs
          const priceChange1h = formatPriceChange(r.dexscreener_price_change_1h);
          const priceChange6h = formatPriceChange(r.dexscreener_price_change_6h);
          const priceChange24h = formatPriceChange(r.dexscreener_price_change_h24);
          
          return `
            <tr>
              <td><span class="fav" onclick="toggleFav('${r.address}')">‚≠ê</span></td>
              <td>
                <strong>${r.symbol}</strong><br>
                <small>
                  <span id="history-${r.address}" style="font-size: 0.7rem;">
                    <span style="color: #888;">‚è≥ V√©rification...</span>
                  </span>
                </small>
              </td>
              <td>${getTokenStatusDisplay(r.status)}</td>
              <td class="price">${(r.dexscreener_price_usd || 0).toFixed(8)}</td>
              <td>${Math.round(r.dexscreener_market_cap || 0).toLocaleString()}</td>
              <td>${(r.dexscreener_liquidity_base || 0).toFixed(2)}</td>
              <td>${Math.round(r.dexscreener_liquidity_quote || 0).toLocaleString()}</td>
              <td>${Math.round(r.dexscreener_volume_1h || 0).toLocaleString()}</td>
              <td>${Math.round(r.dexscreener_volume_6h || 0).toLocaleString()}</td>
              <td>${Math.round(r.dexscreener_volume_24h || 0).toLocaleString()}</td>
              <td class="${priceChange1h.className}">${priceChange1h.text}</td>
              <td class="${priceChange6h.className}">${priceChange6h.text}</td>
              <td class="${priceChange24h.className}">${priceChange24h.text}</td>
              <td>${r.dexscreener_txns_1h || 0}</td>
              <td>${r.dexscreener_txns_6h || 0}</td>
              <td>${r.dexscreener_txns_24h || 0}</td>
              <td style="color: #00ff88">${r.dexscreener_buys_1h || 0}</td>
              <td style="color: #ff6b6b">${r.dexscreener_sells_1h || 0}</td>
              <td style="color: #00ff88">${r.dexscreener_buys_24h || 0}</td>
              <td style="color: #ff6b6b">${r.dexscreener_sells_24h || 0}</td>
              <td>${dexUrlDisplay}</td>
              <td>${pairCreatedAt}</td>
              <td>${lastDexUpdate}</td>
            </tr>
          `;
        }).join('');
    rows.forEach(r => {
      setTimeout(() => checkTokenHistory(r.address), Math.random() * 1000);
    });
      }
    }

    function getTokenStatusDisplay(status) { 
      if (!status) return '<span class="token-status status-unknown">Unknown</span>'; 
      const statusLower = String(status || '').toLowerCase().trim();
      const statusMap = { 'active': '<span class="token-status status-active">Active</span>', 'inactive': '<span class="token-status status-inactive">Inactive</span>', 'no_dex_data': '<span class="token-status status-no_dex_data">No Dex</span>', 'archived': '<span class="token-status status-archived">Archived</span>', 'blacklisted': '<span class="token-status status-blacklisted">Blacklisted</span>' }; 
      return statusMap[statusLower] || `<span class="token-status status-unknown">${status}</span>`; 
    }

    function updateAnalysis() {
      const metricsContainer = document.getElementById('analysisMetrics');
      
      if (filteredData.length === 0) {
        metricsContainer.innerHTML = '<div class="metric-card"><div class="metric-title">Aucune donn√©e √† analyser</div></div>';
        return;
      }

      // ‚úÖ MISE √Ä JOUR: Calculer les m√©triques avec les donn√©es DexScreener
      const totalTokens = filteredData.length;
      const avgScore = filteredData.reduce((sum, token) => sum + (token.invest_score || 0), 0) / totalTokens;
      const avgLiquidity = filteredData.reduce((sum, token) => sum + (token.liquidity_usd || 0), 0) / totalTokens;
      const avgVolume = filteredData.reduce((sum, token) => sum + (token.volume_24h || 0), 0) / totalTokens;
      const avgHolders = filteredData.reduce((sum, token) => sum + (token.holders || 0), 0) / totalTokens;
      
      const highScoreTokens = filteredData.filter(token => (token.invest_score || 0) >= 80).length;
      const activeTokens = filteredData.filter(token => token.bonding_curve_status === 'active').length;
      const migratedTokens = filteredData.filter(token => token.bonding_curve_status === 'migrated').length;
      
      // ‚úÖ NOUVELLES M√âTRIQUES DEXSCREENER
      const tokensWithDexData = filteredData.filter(token => (token.dexscreener_price_usd || 0) > 0).length;
      const totalDexVolume = filteredData.reduce((sum, token) => sum + (token.dexscreener_volume_24h || 0), 0);
      const avgDexPrice = tokensWithDexData > 0 ? 
        filteredData.filter(token => (token.dexscreener_price_usd || 0) > 0)
          .reduce((sum, token) => sum + (token.dexscreener_price_usd || 0), 0) / tokensWithDexData : 0;
      
      const avgDexMarketCap = tokensWithDexData > 0 ?
        filteredData.filter(token => (token.dexscreener_market_cap || 0) > 0)
          .reduce((sum, token) => sum + (token.dexscreener_market_cap || 0), 0) / 
          filteredData.filter(token => (token.dexscreener_market_cap || 0) > 0).length : 0;
      
      const totalDexTxns24h = filteredData.reduce((sum, token) => sum + (token.dexscreener_txns_24h || 0), 0);
      const totalDexBuys24h = filteredData.reduce((sum, token) => sum + (token.dexscreener_buys_24h || 0), 0);
      const totalDexSells24h = filteredData.reduce((sum, token) => sum + (token.dexscreener_sells_24h || 0), 0);

      metricsContainer.innerHTML = `
        <div class="metric-card">
          <div class="metric-title">üìä Tokens Analys√©s</div>
          <div class="metric-value">${totalTokens}</div>
          <div class="metric-subtitle">Dans la s√©lection actuelle</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">‚≠ê Score Moyen</div>
          <div class="metric-value">${avgScore.toFixed(1)}</div>
          <div class="metric-subtitle">Score d'investissement</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">üèÜ Tokens Premium</div>
          <div class="metric-value">${highScoreTokens}</div>
          <div class="metric-subtitle">${((highScoreTokens/totalTokens)*100).toFixed(1)}% avec score ‚â•80</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">üìà Avec Donn√©es DexScreener</div>
          <div class="metric-value">${tokensWithDexData}</div>
          <div class="metric-subtitle">${((tokensWithDexData/totalTokens)*100).toFixed(1)}% des tokens</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">üíß Liquidit√© Moyenne</div>
          <div class="metric-value">${(avgLiquidity/1000).toFixed(1)}K</div>
          <div class="metric-subtitle">Liquidit√© USD moyenne</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">üìä Volume DexScreener 24h</div>
          <div class="metric-value">${(totalDexVolume/1000000).toFixed(2)}M</div>
          <div class="metric-subtitle">Volume total DexScreener</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">üí∞ Prix Moyen DexScreener</div>
          <div class="metric-value">${avgDexPrice.toFixed(6)}</div>
          <div class="metric-subtitle">Prix moyen USD</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">üéØ Market Cap Moyen</div>
          <div class="metric-value">${(avgDexMarketCap/1000000).toFixed(2)}M</div>
          <div class="metric-subtitle">Market cap moyen DexScreener</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">üîÑ Tokens Actifs</div>
          <div class="metric-value">${activeTokens}</div>
          <div class="metric-subtitle">${((activeTokens/totalTokens)*100).toFixed(1)}% en bonding curve</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">üöÄ Tokens Migr√©s</div>
          <div class="metric-value">${migratedTokens}</div>
          <div class="metric-subtitle">${((migratedTokens/totalTokens)*100).toFixed(1)}% sur Raydium</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">üìä Transactions 24h</div>
          <div class="metric-value">${Math.round(totalDexTxns24h/1000)}K</div>
          <div class="metric-subtitle">Total transactions DexScreener</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-title">üíö Ratio Buys/Sells 24h</div>
          <div class="metric-value">${totalDexSells24h > 0 ? (totalDexBuys24h/totalDexSells24h).toFixed(2) : '‚àû'}</div>
          <div class="metric-subtitle">${totalDexBuys24h} buys / ${totalDexSells24h} sells</div>
        </div>
      `;
    }

    function updatePagination() {
      document.getElementById("pageInfo").textContent = 
        `Page ${currentPage} / ${Math.ceil(filteredData.length / perPage)} (${filteredData.length} tokens)`;
      document.getElementById("prevBtn").disabled = currentPage === 1;
      document.getElementById("nextBtn").disabled = currentPage === Math.ceil(filteredData.length / perPage);
    }

    // === FONCTIONS DE PAGINATION ===
    function changePerPage() {
      perPage = +document.getElementById("perPage").value;
      currentPage = 1;
      renderPage();
    }

    function prevPage() {
      if (currentPage > 1) {
        currentPage--;
        renderPage();
      }
    }

    function nextPage() {
      if (currentPage < Math.ceil(filteredData.length / perPage)) {
        currentPage++;
        renderPage();
      }
    }

    // === FONCTIONS DE CONTR√îLE ===
    function reloadData() {
      fetchData();
      document.querySelectorAll('.filter-panel input').forEach(input => input.value = '');
      document.getElementById('filterTimeUnit').value = '';
      document.getElementById('filterBondingStatus').value = '';
      document.getElementById('dexFilterHasData').value = '';
      document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
      applyFilters();
    }

    function resetFilters() {
      document.querySelectorAll('.filter-panel input').forEach(input => input.value = '');
      document.getElementById('filterTimeUnit').value = '';
      document.getElementById('filterBondingStatus').value = '';
      document.getElementById('filterDiscoveredAt').value = '';
      document.getElementById('dexFilterHasData').value = '';
      document.getElementById('dexFilterStatus').value = '';
      document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
      filteredData = [...data];
      currentPage = 1;
      renderPage();
    }

    // V√©rifier l'historique de mani√®re asynchrone
    function checkTokenHistory(address) {
      fetch(`/api/token-has-history/${address}`)
        .then(response => response.json())
        .then(data => {
          const element = document.getElementById(`history-${address}`);
          if (element) {
            if (data.has_history && data.data_points > 0) {
              element.innerHTML = `
                <a href="/dashboard/history?address=${address}" target="_blank" style="color: #00d4ff;">
                  üìä Historique (${data.data_points} pts)
                </a>
              `;
            } else {
              element.innerHTML = '<span style="color: #666;">üìä Pas d\'historique</span>';
            }
          }
        })
        .catch(() => {
          const element = document.getElementById(`history-${address}`);
          if (element) {
            element.innerHTML = '<span style="color: #666;">üìä Pas d\'historique</span>';
          }
        });
    }

    async function toggleFav(address) {
      await fetch(`/api/favorites/${address}`, { method: 'POST' });
      alert('Ajout√© aux favoris !');
    }

    // === √âV√âNEMENTS ===
    let debounceTimeout;
    
    // Filtres onglet base
    document.querySelectorAll('#base-content .filter-panel input, #base-content .filter-panel select').forEach(input => {
      input.addEventListener('input', () => {
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(() => {
          applyFilters();
        }, 300);
      });
    });

    // Filtres onglet DexScreener (modifier la section existante) 
    document.querySelectorAll('#dexscreener-content .filter-panel input, #dexscreener-content .filter-panel select').forEach(input => { 
      input.addEventListener('input', () => { 
        clearTimeout(debounceTimeout); 
        debounceTimeout = setTimeout(() => { 
          applyDexFilters();
        }, 300);
      }); 
    }); // ‚úÖ Event listener sp√©cifique pour le filtre status document.getElementById('dexFilterStatus').addEventListener('change', () => { applyDexFilters(); });

    function highlightActiveFilters() {
  // Base filters
  const baseInputs = [
    'filterSymbol', 'filterBondingStatus', 'filterProgressMin', 'filterProgressMax',
    'filterPriceMin', 'filterPriceMax', 'filterScoreMin', 'filterScoreMax',
    'filterLiquidityMin', 'filterLiquidityMax', 'filterVolumeMin', 'filterVolumeMax',
    'filterHoldersMin', 'filterHoldersMax', 'filterAgeMin', 'filterAgeMax',
    'filterRiskMin', 'filterRiskMax', 'filterDiscoveredAt', 'filterTimeValue', 'filterTimeUnit'
  ];

  baseInputs.forEach(id => {
    const el = document.getElementById(id);
    if (el && el.value.trim() !== '') {
      el.classList.add('filter-active');
    } else {
      el.classList.remove('filter-active');
    }
  });

  // Dex filters
  const dexInputs = [
    'dexFilterSymbol', 'dexFilterStatus', 'dexFilterPriceMin', 'dexFilterPriceMax',
    'dexFilterMarketCapMin', 'dexFilterMarketCapMax', 'dexFilterVolume1hMin',
    'dexFilterVolume6hMin', 'dexFilterVolume24hMin', 'dexFilterTxns24hMin',
    'dexFilterBuys24hMin', 'dexFilterSells24hMax', 'dexFilterLiquidityQuoteMin', 'dexFilterHasData'
  ];

  dexInputs.forEach(id => {
    const el = document.getElementById(id);
    if (el && el.value.trim() !== '') {
      el.classList.add('filter-active');
    } else {
      el.classList.remove('filter-active');
    }
  });

  // Highlight preset buttons
  document.querySelectorAll('.preset-btn').forEach(btn => {
    if (btn.classList.contains('active')) {
      btn.classList.add('filter-active');
    } else {
      btn.classList.remove('filter-active');
    }
  });

  document.querySelectorAll('#dexscreener-content .preset-btn').forEach(btn => {
    if (btn.classList.contains('active')) {
      btn.classList.add('filter-active');
    } else {
      btn.classList.remove('filter-active');
    }
  });

}


    // === INITIALISATION ===
    fetchData();
    startAutoRefresh();
    updateRefreshStatus();
</script>
</body>
</html>