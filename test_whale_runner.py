#!/usr/bin/env python3
"""
üêã Whale Detection Test Runner - Script de test continu
Lance les tests whale en continu avec des logs d√©taill√©s
"""

import asyncio
import logging
import signal
import sqlite3
import time
from datetime import datetime, timedelta
from typing import Dict, List
import sys
import os

# Import du syst√®me whale
try:
    from whale_detector_integration import (
        whale_detector, 
        whale_api,
        start_whale_monitoring, 
        stop_whale_monitoring,
        process_websocket_logs_for_whales,
        WHALE_THRESHOLD_USD,
        CRITICAL_THRESHOLD_USD
    )
except ImportError as e:
    print(f"‚ùå Erreur import: {e}")
    print("üí° Assurez-vous que whale_detector_integration.py est dans le m√™me dossier")
    sys.exit(1)

# Configuration des logs
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('whale_test_runner.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)

logger = logging.getLogger('whale_test_runner')

class WhaleTestRunner:
    """Runner de test continu pour la d√©tection whale"""
    
    def __init__(self, database_path: str = "tokens.db"):
        self.database_path = database_path
        self.running = False
        self.stats = {
            'total_checks': 0,
            'whales_detected': 0,
            'api_calls': 0,
            'errors': 0,
            'start_time': None
        }
        
        # Gestionnaire de signal pour arr√™t propre
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
    
    def signal_handler(self, signum, frame):
        """Gestionnaire d'arr√™t propre"""
        logger.info(f"üõë Signal {signum} re√ßu, arr√™t en cours...")
        self.running = False
    
    async def start_continuous_testing(self):
        """Lancer les tests en continu"""
        logger.info("üöÄ === WHALE DETECTION TEST RUNNER === üöÄ")
        logger.info(f"üìä Seuils: Whale=${WHALE_THRESHOLD_USD:,} | Critique=${CRITICAL_THRESHOLD_USD:,}")
        
        self.running = True
        self.stats['start_time'] = datetime.now()
        
        # Cr√©er des donn√©es de test initiales
        await self.setup_test_data()
        
        # D√©marrer le syst√®me whale
        try:
            await start_whale_monitoring()
            logger.info("‚úÖ Whale monitoring system started")
        except Exception as e:
            logger.error(f"‚ùå Erreur d√©marrage whale monitoring: {e}")
            return
        
        # Lancer les t√¢ches de test en parall√®le
        tasks = [
            self.monitor_whale_activity(),
            self.test_api_endpoints(),
            self.simulate_websocket_logs(),
            self.display_stats(),
            self.check_system_health()
        ]
        
        try:
            await asyncio.gather(*tasks, return_exceptions=True)
        except Exception as e:
            logger.error(f"‚ùå Erreur dans les t√¢ches: {e}")
        finally:
            await stop_whale_monitoring()
            self.display_final_stats()
    
    async def setup_test_data(self):
        """Cr√©er des donn√©es whale de test"""
        logger.info("üîß Setup des donn√©es de test...")
        
        conn = sqlite3.connect(self.database_path)
        cursor = conn.cursor()
        
        try:
            # Nettoyer les anciennes donn√©es de test
            cursor.execute("DELETE FROM whale_transactions_live WHERE wallet_label LIKE '%TEST%'")
            
            # Cr√©er quelques transactions de test
            test_data = [
                {
                    'signature': f'test_signature_{int(time.time())}_{i}',
                    'token_address': 'So11111111111111111111111111111111111111112',
                    'wallet_address': f'test_wallet_{i}aBcDefGhIjKlMnOpQrStUvWxYz123',
                    'transaction_type': 'buy' if i % 2 == 0 else 'sell',
                    'amount_usd': 5000 + (i * 1000),
                    'amount_tokens': 1000000,
                    'timestamp': datetime.now() - timedelta(minutes=i*5),
                    'price_impact': 0.5,
                    'is_known_whale': i % 3 == 0,
                    'wallet_label': f'TEST Whale #{i}',
                    'is_in_database': True,
                    'dex_id': ['jupiter', 'raydium', 'pump_fun'][i % 3]
                }
                for i in range(10)
            ]
            
            for data in test_data:
                cursor.execute('''
                    INSERT OR REPLACE INTO whale_transactions_live (
                        signature, token_address, wallet_address, transaction_type,
                        amount_usd, amount_tokens, timestamp, price_impact,
                        is_known_whale, wallet_label, is_in_database, dex_id
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    data['signature'], data['token_address'], data['wallet_address'],
                    data['transaction_type'], data['amount_usd'], data['amount_tokens'],
                    data['timestamp'], data['price_impact'], data['is_known_whale'],
                    data['wallet_label'], data['is_in_database'], data['dex_id']
                ))
            
            conn.commit()
            logger.info(f"‚úÖ Cr√©√© {len(test_data)} transactions whale de test")
            
        except Exception as e:
            logger.error(f"‚ùå Erreur setup donn√©es test: {e}")
            self.stats['errors'] += 1
        finally:
            conn.close()
    
    async def monitor_whale_activity(self):
        """Monitorer l'activit√© whale en continu"""
        logger.info("üëÄ D√©marrage monitoring activit√© whale...")
        
        last_check = datetime.now()
        
        while self.running:
            try:
                # V√©rifier les nouvelles transactions
                new_whales = self.get_new_whale_transactions(last_check)
                
                if new_whales:
                    self.stats['whales_detected'] += len(new_whales)
                    logger.info(f"üêã {len(new_whales)} nouvelles transactions whale d√©tect√©es!")
                    
                    for whale in new_whales:
                        amount = whale['amount_usd']
                        tx_type = whale['transaction_type'].upper()
                        dex = whale['dex_id']
                        
                        if amount >= CRITICAL_THRESHOLD_USD:
                            logger.warning(f"üö® CRITIQUE: ${amount:,.0f} {tx_type} sur {dex}")
                        else:
                            logger.info(f"üí∞ WHALE: ${amount:,.0f} {tx_type} sur {dex}")
                
                last_check = datetime.now()
                self.stats['total_checks'] += 1
                
                await asyncio.sleep(10)  # Check toutes les 10 secondes
                
            except Exception as e:
                logger.error(f"‚ùå Erreur monitoring whale: {e}")
                self.stats['errors'] += 1
                await asyncio.sleep(30)
    
    def get_new_whale_transactions(self, since: datetime) -> List[Dict]:
        """R√©cup√©rer les nouvelles transactions whale"""
        conn = sqlite3.connect(self.database_path)
        cursor = conn.cursor()
        
        try:
            cursor.execute('''
                SELECT * FROM whale_transactions_live 
                WHERE created_at > ?
                ORDER BY timestamp DESC
                LIMIT 50
            ''', (since,))
            
            columns = [desc[0] for desc in cursor.description]
            results = []
            
            for row in cursor.fetchall():
                results.append(dict(zip(columns, row)))
            
            return results
            
        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration nouvelles whales: {e}")
            return []
        finally:
            conn.close()
    
    async def test_api_endpoints(self):
        """Tester les endpoints API p√©riodiquement"""
        logger.info("üîå D√©marrage test API endpoints...")
        
        while self.running:
            try:
                # Test r√©sum√© whale
                summary = whale_api.get_whale_activity_summary()
                self.stats['api_calls'] += 1
                
                if summary:
                    logger.info(f"üìä API Summary: {summary['total_transactions']} tx, ${summary['total_volume_usd']:,.0f} volume")
                else:
                    logger.warning("‚ö†Ô∏è API Summary retourne vide")
                
                # Test activit√© r√©cente
                recent = whale_api.get_recent_whale_activity(hours=1, limit=5)
                self.stats['api_calls'] += 1
                
                logger.info(f"üìà API Recent: {len(recent)} transactions derni√®re heure")
                
                await asyncio.sleep(60)  # Test API toutes les minutes
                
            except Exception as e:
                logger.error(f"‚ùå Erreur test API: {e}")
                self.stats['errors'] += 1
                await asyncio.sleep(120)
    
    async def simulate_websocket_logs(self):
        """Simuler des logs WebSocket pour tester le parsing"""
        logger.info("üì° D√©marrage simulation WebSocket...")
        
        # Logs de test r√©alistes
        test_logs_scenarios = [
            {
                'signature': f'simulated_jupiter_{int(time.time())}',
                'logs': [
                    'Program JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4 invoke [1]',
                    'Program log: Instruction: Route',
                    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]',
                    'Program data: large_swap_detected'
                ]
            },
            {
                'signature': f'simulated_raydium_{int(time.time())}',
                'logs': [
                    'Program 675kPX9MHTjS2zt1qfr1NYHuzeLXfQM9H24wFSUt1Mp8 invoke [1]',
                    'Program log: swap_base_in',
                    'Program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA invoke [2]'
                ]
            },
            {
                'signature': f'simulated_pumpfun_{int(time.time())}',
                'logs': [
                    'Program 6EF8rrecthR5Dkzon8Nwu78hRvfCKubJ14M5uBEwF6P invoke [1]',
                    'Program log: Instruction: Buy',
                    'Program data: pump_buy_large_amount'
                ]
            }
        ]
        
        while self.running:
            try:
                for scenario in test_logs_scenarios:
                    if not self.running:
                        break
                    
                    logger.info(f"üß™ Test parsing: {scenario['signature']}")
                    
                    # Simuler le traitement WebSocket
                    await process_websocket_logs_for_whales(
                        scenario['signature'], 
                        scenario['logs']
                    )
                    
                    await asyncio.sleep(30)  # Attendre entre simulations
                
                await asyncio.sleep(300)  # Cycle complet toutes les 5 minutes
                
            except Exception as e:
                logger.error(f"‚ùå Erreur simulation WebSocket: {e}")
                self.stats['errors'] += 1
                await asyncio.sleep(180)
    
    async def display_stats(self):
        """Afficher les statistiques p√©riodiquement"""
        while self.running:
            try:
                uptime = datetime.now() - self.stats['start_time']
                
                logger.info("üìä === STATS WHALE TEST RUNNER ===")
                logger.info(f"   ‚è±Ô∏è  Uptime: {uptime}")
                logger.info(f"   üîç Checks totaux: {self.stats['total_checks']}")
                logger.info(f"   üêã Whales d√©tect√©es: {self.stats['whales_detected']}")
                logger.info(f"   üîå Appels API: {self.stats['api_calls']}")
                logger.info(f"   ‚ùå Erreurs: {self.stats['errors']}")
                
                # Stats base de donn√©es
                conn = sqlite3.connect(self.database_path)
                cursor = conn.cursor()
                
                cursor.execute("SELECT COUNT(*) FROM whale_transactions_live WHERE timestamp > datetime('now', '-1 hour')")
                whales_1h = cursor.fetchone()[0]
                
                cursor.execute("SELECT COUNT(*) FROM whale_transactions_live WHERE timestamp > datetime('now', '-24 hours')")
                whales_24h = cursor.fetchone()[0]
                
                conn.close()
                
                logger.info(f"   üíæ DB Whales 1h: {whales_1h}")
                logger.info(f"   üíæ DB Whales 24h: {whales_24h}")
                logger.info("=" * 40)
                
                await asyncio.sleep(120)  # Stats toutes les 2 minutes
                
            except Exception as e:
                logger.error(f"‚ùå Erreur affichage stats: {e}")
                await asyncio.sleep(180)
    
    async def check_system_health(self):
        """V√©rifier la sant√© du syst√®me"""
        while self.running:
            try:
                # V√©rifier que le whale_detector est actif
                if not whale_detector.is_running:
                    logger.warning("‚ö†Ô∏è Whale detector n'est pas en cours d'ex√©cution!")
                
                # V√©rifier la base de donn√©es
                conn = sqlite3.connect(self.database_path)
                cursor = conn.cursor()
                
                # Test requ√™te simple
                cursor.execute("SELECT COUNT(*) FROM whale_transactions_live")
                total_whales = cursor.fetchone()[0]
                
                if total_whales == 0:
                    logger.warning("‚ö†Ô∏è Aucune transaction whale en base!")
                
                conn.close()
                
                # V√©rifier les logs r√©cents
                recent_errors = self.stats['errors']
                if recent_errors > 10:
                    logger.warning(f"‚ö†Ô∏è Nombre d'erreurs √©lev√©: {recent_errors}")
                
                await asyncio.sleep(300)  # Health check toutes les 5 minutes
                
            except Exception as e:
                logger.error(f"‚ùå Erreur health check: {e}")
                self.stats['errors'] += 1
                await asyncio.sleep(300)
    
    def display_final_stats(self):
        """Afficher les stats finales"""
        uptime = datetime.now() - self.stats['start_time'] if self.stats['start_time'] else timedelta(0)
        
        logger.info("üèÅ === STATS FINALES WHALE TEST RUNNER ===")
        logger.info(f"   ‚è±Ô∏è  Dur√©e totale: {uptime}")
        logger.info(f"   üîç Checks totaux: {self.stats['total_checks']}")
        logger.info(f"   üêã Whales d√©tect√©es: {self.stats['whales_detected']}")
        logger.info(f"   üîå Appels API: {self.stats['api_calls']}")
        logger.info(f"   ‚ùå Erreurs: {self.stats['errors']}")
        
        if uptime.total_seconds() > 0:
            rate = self.stats['whales_detected'] / (uptime.total_seconds() / 3600)
            logger.info(f"   üìà Taux d√©tection: {rate:.2f} whales/heure")
        
        logger.info("üéâ Test runner termin√© avec succ√®s!")

async def main():
    """Point d'entr√©e principal"""
    
    print("üêã === WHALE DETECTION CONTINUOUS TEST RUNNER === üêã")
    print("Ce script va tester la d√©tection whale en continu.")
    print("Appuyez sur Ctrl+C pour arr√™ter proprement.\n")
    
    # V√©rifier les d√©pendances
    if not os.path.exists("tokens.db"):
        print("‚ö†Ô∏è Warning: tokens.db n'existe pas, il sera cr√©√© automatiquement")
    
    try:
        runner = WhaleTestRunner()
        await runner.start_continuous_testing()
        
    except KeyboardInterrupt:
        logger.info("üëã Arr√™t demand√© par l'utilisateur")
    except Exception as e:
        logger.error(f"‚ùå Erreur fatale: {e}", exc_info=True)
        return 1
    
    return 0

if __name__ == "__main__":
    try:
        exit_code = asyncio.run(main())
        sys.exit(exit_code)
    except KeyboardInterrupt:
        print("\nüëã Au revoir!")
        sys.exit(0)