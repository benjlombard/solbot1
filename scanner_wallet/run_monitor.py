#!/usr/bin/env python3
"""
Script de d√©marrage optimis√© pour le moniteur Solana
Avec diagnostics avanc√©s et gestion intelligente des comptes de tokens
"""

import os
import sys
import logging
import threading
import time
import sqlite3
from datetime import datetime
from dotenv import load_dotenv

def setup_environment():
    """Configure l'environnement et les variables"""
    if os.path.exists('.env'):
        load_dotenv('.env')
        print("‚úÖ Fichier .env charg√©")
    else:
        print("‚ÑπÔ∏è Aucun fichier .env trouv√©, utilisation des variables par d√©faut")
    
    # V√©rifier les d√©pendances
    try:
        import requests
        import flask
        import flask_cors
        print("‚úÖ Toutes les d√©pendances sont install√©es")
    except ImportError as e:
        print(f"‚ùå D√©pendance manquante: {e}")
        print("üí° Ex√©cutez: pip install -r requirements.txt")
        sys.exit(1)

def check_configuration():
    """V√©rifie la configuration avec diagnostics avanc√©s"""
    try:
        from config import DefaultConfig as Config
        
        errors = []
        warnings = []
        
        # V√©rification des wallets
        if not hasattr(Config, 'WALLET_ADDRESSES') or not Config.WALLET_ADDRESSES:
            errors.append("WALLET_ADDRESSES invalide ou vide")
        else:
            for i, wallet in enumerate(Config.WALLET_ADDRESSES):
                if not wallet or len(wallet) < 40:
                    errors.append(f"Wallet #{i+1} invalide: {wallet}")
        
        # V√©rification des param√®tres de performance
        if Config.UPDATE_INTERVAL < 30:
            warnings.append("UPDATE_INTERVAL tr√®s faible - risque de rate limiting")
        
        if Config.RATE_LIMIT_DELAY < 0.1:
            warnings.append("RATE_LIMIT_DELAY tr√®s faible - risque de rate limiting")
            
        if Config.TOKEN_DISCOVERY_BATCH_SIZE > 100:
            warnings.append("TOKEN_DISCOVERY_BATCH_SIZE √©lev√© - peut ralentir les scans")
        
        # V√©rifier les endpoints RPC
        try:
            endpoints = Config.get_rpc_endpoints()
            if not endpoints:
                errors.append("Aucun endpoint RPC configur√©")
            else:
                print(f"üîó {len(endpoints)} endpoint(s) RPC configur√©(s)")
        except Exception as e:
            errors.append(f"Erreur dans get_rpc_endpoints: {e}")
        
        if errors:
            raise ValueError(f"Erreurs critiques: {'; '.join(errors)}")
        
        if warnings:
            print("‚ö†Ô∏è Avertissements de configuration:")
            for warning in warnings:
                print(f"   - {warning}")
        
        print("‚úÖ Configuration valid√©e")
        
        # Afficher les param√®tres principaux
        print(f"\nüìç Configuration actuelle:")
        print(f"   üíº Wallets: {len(Config.WALLET_ADDRESSES)} wallet(s)")
        for i, wallet in enumerate(Config.WALLET_ADDRESSES):
            print(f"      {i+1}. {wallet[:8]}...{wallet[-8:]}")
        print(f"   üîë QuickNode: {'‚úÖ Configur√©' if hasattr(Config, 'QUICKNODE_ENDPOINT') and Config.QUICKNODE_ENDPOINT else '‚ùå Non configur√©'}")
        print(f"   ‚è±Ô∏è Intervalle: {Config.UPDATE_INTERVAL}s")
        print(f"   üö¶ Rate limit: {Config.RATE_LIMIT_DELAY}s entre requ√™tes")
        print(f"   üìä Scan complet: toutes les {Config.FULL_SCAN_INTERVAL_HOURS}h")
        print(f"   üéØ Limite transactions: {Config.DEFAULT_TRANSACTION_LIMIT}")
        print(f"   üì¶ Batch size: {Config.TOKEN_DISCOVERY_BATCH_SIZE}")
        
        return Config
        
    except Exception as e:
        print(f"‚ùå Erreur de configuration: {e}")
        sys.exit(1)

def test_database_connection(db_name: str):
    """Teste et affiche les informations de la base de donn√©es"""
    try:
        print("üóÑÔ∏è Test de connexion √† la base de donn√©es...")
        conn = sqlite3.connect(db_name)
        cursor = conn.cursor()
        
        # V√©rifier les tables principales
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
        tables = [row[0] for row in cursor.fetchall()]
        
        print(f"‚úÖ Base de donn√©es connect√©e: {db_name}")
        print(f"üìä Tables trouv√©es: {len(tables)}")
        
        # Statistiques par table
        stats = {}
        for table in ['transactions', 'token_accounts', 'scan_history']:
            if table in tables:
                cursor.execute(f"SELECT COUNT(*) FROM {table}")
                count = cursor.fetchone()[0]
                stats[table] = count
                print(f"   - {table}: {count:,} enregistrements")
        
        # Statistiques des wallets en DB
        if 'token_accounts' in tables:
            cursor.execute("SELECT wallet_address, COUNT(*) FROM token_accounts GROUP BY wallet_address")
            wallet_stats = cursor.fetchall()
            if wallet_stats:
                print(f"üíº Comptes de tokens par wallet:")
                for wallet, count in wallet_stats:
                    print(f"   - {wallet[:8]}...{wallet[-8:]}: {count:,} comptes")
        
        # Derni√®res activit√©s
        if 'transactions' in tables and stats.get('transactions', 0) > 0:
            cursor.execute("""
                SELECT token_symbol, transaction_type, block_time 
                FROM transactions 
                WHERE is_token_transaction = 1 
                ORDER BY block_time DESC 
                LIMIT 3
            """)
            recent_txs = cursor.fetchall()
            if recent_txs:
                print(f"üìà Derni√®res transactions token:")
                for symbol, tx_type, block_time in recent_txs:
                    if block_time:
                        age = int(time.time()) - block_time
                        age_str = f"{age//3600}h{(age%3600)//60}m" if age < 86400 else f"{age//86400}j"
                        print(f"   - {symbol}: {tx_type} (il y a {age_str})")
        
        conn.close()
        return True
        
    except Exception as e:
        print(f"‚ùå Erreur base de donn√©es: {e}")
        return False

def test_quicknode_connection():
    """Teste la connexion QuickNode avec diagnostics d√©taill√©s"""
    try:
        from config import DefaultConfig as Config
        import requests
        
        endpoints = Config.get_rpc_endpoints()
        print(f"üß™ Test de connexion RPC sur {len(endpoints)} endpoint(s)...")
        
        for i, endpoint in enumerate(endpoints):
            print(f"   üîó Test endpoint #{i+1}: {endpoint[:50]}...")
            
            payload = {
                "jsonrpc": "2.0",
                "id": 1,
                "method": "getHealth",
                "params": []
            }
            
            try:
                headers = Config.get_rpc_headers()
                start_time = time.time()
                response = requests.post(endpoint, json=payload, headers=headers, timeout=10)
                response_time = (time.time() - start_time) * 1000
                
                if response.status_code == 200:
                    print(f"   ‚úÖ Endpoint #{i+1} OK ({response_time:.0f}ms)")
                    if i == 0:  # Premier endpoint (principal)
                        print(f"   üéØ Endpoint principal fonctionnel")
                        return True
                else:
                    print(f"   ‚ö†Ô∏è Endpoint #{i+1} erreur {response.status_code}")
                    
            except requests.exceptions.Timeout:
                print(f"   ‚è∞ Endpoint #{i+1} timeout")
            except Exception as e:
                print(f"   ‚ùå Endpoint #{i+1} erreur: {e}")
        
        print("‚ö†Ô∏è Aucun endpoint principal disponible, utilisation des fallbacks")
        return False
        
    except Exception as e:
        print(f"‚ùå Erreur test connexion RPC: {e}")
        return False

def test_wallet_data_fetch():
    """Teste la r√©cup√©ration de donn√©es pour un wallet"""
    try:
        from config import DefaultConfig as Config
        from scanner_wallet import SolanaWalletMonitor
        
        if not Config.WALLET_ADDRESSES:
            print("‚ùå Aucun wallet configur√© pour le test")
            return False
        
        test_wallet = Config.WALLET_ADDRESSES[0]
        print(f"üß™ Test de r√©cup√©ration de donn√©es pour {test_wallet[:8]}...")
        
        monitor = SolanaWalletMonitor([test_wallet], Config.DB_NAME)
        
        # Test 1: R√©cup√©ration du solde
        print("   üìä Test du solde SOL...")
        balance = monitor.get_wallet_balance_for_address(test_wallet)
        if balance >= 0:
            print(f"   ‚úÖ Solde r√©cup√©r√©: {balance:.4f} SOL")
        else:
            print("   ‚ö†Ô∏è Solde non r√©cup√©r√©")
        
        # Test 2: D√©couverte des comptes de tokens (limit√©)
        print("   üîç Test de d√©couverte des comptes de tokens...")
        total_accounts, new_accounts = monitor.discover_token_accounts(test_wallet, force_full_scan=False)
        
        if total_accounts > 0:
            print(f"   ‚úÖ D√©couverte r√©ussie: {total_accounts} comptes ({new_accounts} nouveaux)")
            
            # Test 3: R√©cup√©ration des comptes prioritaires
            print("   üéØ Test des comptes prioritaires...")
            priority_accounts = monitor.get_priority_accounts_for_scanning(test_wallet, limit=5)
            print(f"   ‚úÖ {len(priority_accounts)} comptes prioritaires identifi√©s")
            
            return True
        else:
            print("   ‚ö†Ô∏è Aucun compte de token trouv√©")
            return False
            
    except Exception as e:
        print(f"   ‚ùå Erreur test wallet: {e}")
        return False

def show_startup_summary(Config):
    """Affiche un r√©sum√© du d√©marrage"""
    print("\n" + "=" * 70)
    print("üöÄ R√âSUM√â DU D√âMARRAGE - MONITEUR SOLANA OPTIMIS√â")
    print("=" * 70)
    print(f"üìÖ D√©marrage: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"üîß Version: 2.0 - Approche Balance Changes Intelligente")
    print(f"üíº Wallets surveill√©s: {len(Config.WALLET_ADDRESSES)}")
    print(f"‚è±Ô∏è Cycle de monitoring: {Config.UPDATE_INTERVAL}s")
    print(f"üîÑ Scan complet automatique: {Config.FULL_SCAN_INTERVAL_HOURS}h")
    print(f"üö¶ Rate limiting: {Config.RATE_LIMIT_DELAY}s entre requ√™tes")
    print(f"üåê Interface web: http://{Config.FLASK_HOST}:{Config.FLASK_PORT}")
    print("=" * 70)
    print("üéØ STRAT√âGIE OPTIMIS√âE:")
    print("   1Ô∏è‚É£ D√©couverte intelligente des comptes de tokens")
    print("   2Ô∏è‚É£ Priorisation des comptes nouveaux/r√©cents")
    print("   3Ô∏è‚É£ Scan cibl√© des balance changes")
    print("   4Ô∏è‚É£ Cache persistant en base de donn√©es")
    print("   5Ô∏è‚É£ Respect strict du rate limiting")
    print("=" * 70)
    print("üìä LOGS:")
    print("   üìù Fichier: wallet_monitor.log")
    print("   üñ•Ô∏è Console: logs en temps r√©el")
    print("   üìà Progression d√©taill√©e des scans")
    print("=" * 70)
    print("‚ö° OPTIMISATIONS:")
    print("   ‚úÖ √âvite les scans redondants")
    print("   ‚úÖ Gestion intelligente des priorit√©s")
    print("   ‚úÖ Cache des m√©tadonn√©es tokens")
    print("   ‚úÖ Fallbacks automatiques RPC")
    print("   ‚úÖ Historique d√©taill√© des scans")
    print("=" * 70)
    
def run_monitor():
    """Lance le moniteur de wallets"""
    try:
        from scanner_wallet import SolanaWalletMonitor, WALLET_ADDRESSES, DB_NAME
        
        print("üîç Initialisation du moniteur optimis√©...")
        monitor = SolanaWalletMonitor(WALLET_ADDRESSES, DB_NAME)
        
        print("üöÄ D√©marrage de la boucle de monitoring intelligente...")
        print("üí° Le premier cycle peut √™tre plus long (d√©couverte initiale)")
        print("‚èπÔ∏è Ctrl+C pour arr√™ter proprement")
        
        monitor.monitor_loop()
        
    except KeyboardInterrupt:
        print("\nüõë Arr√™t demand√© par l'utilisateur")
        print("‚úÖ Moniteur arr√™t√© proprement")
    except Exception as e:
        print(f"‚ùå Erreur dans le monitoring: {e}")
        import traceback
        traceback.print_exc()

def run_diagnostics():
    """Lance des diagnostics complets avant le d√©marrage"""
    print("üî¨ DIAGNOSTICS PR√â-D√âMARRAGE")
    print("=" * 50)
    
    # Test 1: Configuration
    print("1Ô∏è‚É£ V√©rification de la configuration...")
    Config = check_configuration()
    print("‚úÖ Configuration OK\n")
    
    # Test 2: Base de donn√©es
    print("2Ô∏è‚É£ Test de la base de donn√©es...")
    db_ok = test_database_connection(Config.DB_NAME)
    if db_ok:
        print("‚úÖ Base de donn√©es OK\n")
    else:
        print("‚ö†Ô∏è Probl√®me base de donn√©es\n")
    
    # Test 3: Connectivit√© RPC
    print("3Ô∏è‚É£ Test des endpoints RPC...")
    rpc_ok = test_quicknode_connection()
    if rpc_ok:
        print("‚úÖ RPC principal OK\n")
    else:
        print("‚ö†Ô∏è RPC principal en probl√®me, fallbacks disponibles\n")
    
    # Test 4: Donn√©es wallet (optionnel et rapide)
    response = input("4Ô∏è‚É£ Tester la r√©cup√©ration de donn√©es wallet? (o/N): ")
    if response.lower() in ['o', 'oui', 'y', 'yes']:
        print("Test des donn√©es wallet...")
        wallet_ok = test_wallet_data_fetch()
        if wallet_ok:
            print("‚úÖ Donn√©es wallet OK\n")
        else:
            print("‚ö†Ô∏è Probl√®me donn√©es wallet\n")
    
    print("üî¨ DIAGNOSTICS TERMIN√âS")
    print("=" * 50)
    
    return Config

def main():
    """Point d'entr√©e principal avec diagnostics"""
    print("üöÄ D√âMARRAGE DU MONITEUR SOLANA OPTIMIS√â")
    print("=" * 60)
    
    # Configuration de l'environnement
    setup_environment()
    
    # Diagnostics complets
    Config = run_diagnostics()
    
    # Afficher le r√©sum√©
    show_startup_summary(Config)
    
    # Confirmation avant d√©marrage
    print("\nüéØ Pr√™t √† d√©marrer le monitoring optimis√©!")
    response = input("‚ñ∂Ô∏è D√©marrer maintenant? (O/n): ")
    if response.lower() in ['n', 'non', 'no']:
        print("üõë D√©marrage annul√© par l'utilisateur")
        sys.exit(0)
    
    print("\nüé¨ D√âMARRAGE EN COURS...")
    print("=" * 60)
    
    # Importer et d√©marrer l'application
    try:
        # Importer l'application Flask depuis scanner_wallet
        from scanner_wallet import app
        
        # D√©marrer le monitoring en arri√®re-plan
        monitor_thread = threading.Thread(target=run_monitor, daemon=True)
        monitor_thread.start()
        print("‚úÖ Thread de monitoring d√©marr√© en arri√®re-plan")
        
        # Attendre un peu que le monitoring d√©marre
        time.sleep(2)
        
        # Configuration Flask
        host = getattr(Config, 'FLASK_HOST', '127.0.0.1')
        port = getattr(Config, 'FLASK_PORT', 5000)
        debug = getattr(Config, 'FLASK_DEBUG', False)  # Debug d√©sactiv√© en production
        
        print(f"üåê D√©marrage du serveur web sur http://{host}:{port}")
        print("üìä Dashboard accessible dans votre navigateur")
        print("\nüí° CONSEILS D'UTILISATION:")
        print("   - Le premier scan peut prendre plusieurs minutes")
        print("   - Les logs d√©taill√©s sont dans wallet_monitor.log")
        print("   - Le monitoring continue en arri√®re-plan")
        print("   - Ctrl+C pour arr√™ter proprement")
        print(f"   - {len(Config.WALLET_ADDRESSES)} wallet(s) surveill√©(s) intelligemment")
        print("\nüìà PROGRESSION:")
        print("   - D√©couverte initiale des comptes de tokens en cours...")
        print("   - Les premi√®res transactions appara√Ætront sous peu")
        print("   - L'interface se mettra √† jour automatiquement")
        print("\n" + "=" * 60)
        
        # D√©marrer le serveur Flask (bloquant)
        app.run(host=host, port=port, debug=debug, use_reloader=False)
        
    except KeyboardInterrupt:
        print("\nüõë Arr√™t demand√© par l'utilisateur")
        print("‚úÖ Moniteur arr√™t√© proprement")
        sys.exit(0)
    except Exception as e:
        print(f"‚ùå Erreur lors du d√©marrage: {e}")
        import traceback
        traceback.print_exc()
        print("üí° Essayez: python scanner_wallet.py")
        sys.exit(1)

if __name__ == "__main__":
    main()